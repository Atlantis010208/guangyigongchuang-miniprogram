## 原因分析
- 同一页面重复创建监听或监听对象未正确关闭，导致 SDK 状态机在 CONNECTED 状态再次接收 connectionSuccess 事件。
- 监听对象的 onError 必须在 watch 的参数中传入；当前页在返回的 watcher 上追加 onError 并不生效。
- 大列表或网络抖动下，初始化/重连更易触发状态异常。

## 改造方案
1) 仓库层：接收 onError 并限制监听规模
- `utils/api.js`
  - `OrdersRepo.watchByUser(userId, onChange, onError)`：使用 `where({ userId }).orderBy('createdAt','desc').limit(200).watch({ onChange, onError })`。
  - `RequestsRepo.watchByUser(userId, onChange, onError)`：同样接入 onError 与 orderBy、limit。

2) 页面层：一次性、带退避的监听管理
- `pages/cart/cart.js`
  - 在 `startWatchers()` 内改为向仓库传入 `onError`，移除对返回 watcher 的 `.onError(...)` 追加。
  - 保留幂等与延时启动（200ms）；错误时：关闭 watcher、指数退避（<=5 次），再调用 `startWatchers()`。
  - 监听网络：`wx.onNetworkStatusChange` 在断网时关闭 watcher、联网后重启。
  - 严格关闭：`onHide/onUnload` 中 `close()` 并重置 `_watching/_watchRetry/_watchTimer`。

3) 文档更新
- 在 `docs/cloud-data-setup.md` 增加“实时监听稳健性”章节：
  - 接入 onError 正确姿势；限制监听规模（orderBy+limit）；重连策略与网络监听；避免重复创建。

## 验证
- 打开订单管理页不再出现状态机错误；断网/重连后监听可恢复；订单与请求变更实时推送。

## 说明
- 若预计用户单人订单超 200，可提升 limit 或按分页拆分多个监听；同时避免一次监听超过 5000（官方限制）。