# 目标
将前端对订单/请求的写操作统一迁移到云函数调用，完成关键页面的改造与联调；当前端不直接调用 HTTP 服务的情况下，保留仓库层读取/监听，必要处新增云托管接口的可插拔调用点。完成后以用例和命令验证联调结果，并更新接口文档。

## 改造范围（文件级）
- pages/cart/cart.js
  - onDeleteRequest/onDeleteMallOrder：把 `db.collection('requests').where(...).update` 迁移为 `wx.cloud.callFunction('requests_remove')`；如涉及订单同时使用 `orders_remove`。
  - 监听与列表保留，错误恢复策略不变。
- pages/order/detail/detail.js
  - onCancel：迁移为 `wx.cloud.callFunction('requests_update',{ status: 'canceled' })`。
  - onDelete：迁移为 `orders_remove` 与 `requests_remove`。
- pages/order/confirm/confirm.js
  - 支付后同步：迁移为 `orders_update` 与 `requests_update` 替代 `where().update`。
- pages/request/progress/progress.js
  - onDeleteOrder：迁移为 `orders_remove` 与 `requests_remove`。
- 保持 categories/*、flows/* 的 `create` 逻辑先用仓库封装（Requests.create/Orders.create），后续可以逐步替换为云函数 `*_create`。

## 联调步骤
1. 为以上页面新增统一的 `callCf` 方法：封装 `wx.cloud.callFunction` 与错误处理，返回 `{success, code, errorMessage, data}`。
2. 将写入点替换为云函数调用，并在成功后更新本地状态（如列表刷新/提示）。
3. 保留监听（watch）与分页逻辑；统一过滤 `isDelete: 0` 已在仓库层完成。
4. 本地验证：
   - 触发删除/取消/支付后同步，观察云函数返回与页面状态变化。
   - 控制台检查集合文档的 `isDelete/status/updatedAt` 更新。
5. 文档更新：为 `docs/backend-api.md` 增补前端调用示例，为 `docs/backend-implementation-log.md` 记录联调变更与验证步骤。

## 设计原则
- 不改动数据模型与返回规范：统一使用 `{ ok/code/errorMessage }` 或 `{ success/code/... }`。
- 逐步迁移策略：先迁移直接 `db.collection(...).update` 的写操作，后续再将 `Requests.create/Orders.create` 替换为云函数以加强权限控制。
- 安全：云函数侧已使用 `openid` 约束 `userId`；不在前端暴露云托管敏感接口。

## 验证用例
- 订单删除：在 cart/request/progress/detail 页面分别执行删除，云端文档 `isDelete` 设为 1，前端列表不再显示。
- 订单取消：detail 页执行取消，`requests.status` 变更为 `canceled`。
- 支付后同步：confirm 页执行模拟支付后调用更新，`orders.status` 与 `requests` 对应状态更新。

确认后，我将开始修改上述页面并完成联调与文档补充。